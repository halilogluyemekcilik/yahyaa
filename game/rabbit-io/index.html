<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Tavşan Sayma — Gelişmiş (Puan + Ses + Mobil Dokunmatik)</title>
<style>
  :root{
    --bg:#041225; --panel:#0b1626; --accent:#ff7b7b; --muted:#9fb3d6; --glass: rgba(255,255,255,0.03);
    --text:#e6eef8;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Arial;}
  html, body { overflow: hidden; }
  html,body{height:100%}
  body{margin:0; min-height:100vh; background:linear-gradient(180deg,#02121a,#07182a); color:var(--text); display:flex; align-items:center; justify-content:center; padding:18px;}
  .app{width:100%; max-width:1280px;}
  .card{background:var(--panel); border-radius:12px; padding:18px; box-shadow:0 12px 40px rgba(0,0,0,0.6);}
  header{display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;}
  h1{margin:0; font-size:20px;}
  p.small{margin:6px 0 0; color:var(--muted); font-size:13px;}
  .screen{display:none;}
  .screen.active{display:block;}
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
  select, button{padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04); background:var(--glass); color:var(--text); cursor:pointer;}
  .players-setup{display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;}
  .player-card{background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; width:calc(25% - 9px); min-width:160px;}
  .key-box{min-width:74px; padding:10px; text-align:center; background:#071020; border-radius:8px; border:1px dashed rgba(255,255,255,0.05); cursor:pointer;}
  .start-btn{margin-top:14px; background:linear-gradient(90deg,var(--accent),#ffafaf); border:none; font-weight:700;}
  @media (max-width:900px){ .player-card{width:calc(50% - 9px);} }

  .main-row{display:flex; gap:12px; margin-top:12px;}
  .left-col{flex:1; min-width:0;}
  .right-col{width:280px;}
  @media (max-width:820px){ .main-row{flex-direction:column;} .right-col{width:100%;} }

  .game-area{
    position:relative;
    height:clamp(380px, 62vh, 640px);
    background:linear-gradient(180deg,#08182a,#052033);
    border-radius:12px; overflow:hidden;
    border:1px solid rgba(255,255,255,0.06);
    outline:none;
    touch-action:none;
    -webkit-user-select:none; user-select:none;
  }
  .hud{display:flex; gap:8px; margin-top:10px; align-items:center; flex-wrap:wrap;}
  .player-hud{background:rgba(255,255,255,0.03); padding:10px 12px; border-radius:10px; display:flex; gap:10px; align-items:center; min-width:170px;}
  .player-dot{width:14px;height:14px;border-radius:50%;}
  .player-name{font-weight:700;}
  .round-info{margin-left:auto; color:var(--muted);}
  @media (max-width:820px){ .round-info{width:100%; margin-left:0; margin-top:6px;} }

  .scoreboard{background:rgba(255,255,255,0.03); padding:12px; border-radius:12px;}
  .score-row{display:flex; justify-content:space-between; padding:8px 2px; border-bottom:1px dashed rgba(255,255,255,0.06); font-size:14px;}
  .score-row:last-child{border-bottom:none;}
  .score-title{font-weight:800; margin-bottom:8px;}

  .rabbit{
    position:absolute; width:64px; height:64px; border-radius:14px;
    display:flex; align-items:center; justify-content:center;
    user-select:none; pointer-events:none; box-shadow:0 10px 22px rgba(0,0,0,0.5);
    transition:none; will-change: transform;
  }
  .rabbit .body{width:46px;height:46px;border-radius:12px; position:relative;}
  .ear{position:absolute; top:-12px; width:11px; height:22px; border-radius:12px; background:rgba(255,255,255,0.4);}
  .ear.r{right:6px; transform:rotate(12deg);}
  .eye{position:absolute; width:5px; height:5px; border-radius:50%; top:14px; left:11px; background:#111;}
  .rabbit.white .body{background:#fff;}
  .rabbit.red .body{background:#ff6b6b;}
  .rabbit.slow{filter:brightness(0.95) saturate(0.9) contrast(0.96); box-shadow:0 4px 14px rgba(0,0,0,0.5);}
  .rabbit.reverse .body{outline:2px dashed rgba(0,0,0,0.06);}
  .rabbit.fade{opacity:0; transition:opacity .18s;}

  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(0deg, rgba(2,6,12,0.35), rgba(2,6,12,0.35)); font-size:84px; font-weight:900; z-index:50; pointer-events:none; color:#fff;}
  .overlay.small{font-size:48px;}

  .touch-guides{position:absolute; inset:0; z-index:40; pointer-events:none; display:flex;}
  .touch-guide{flex:1; border-left:2px dashed rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:center; color:rgba(255,255,255,0.16); font-weight:800; font-size:18px;}
  .touch-guide:first-child{border-left:none;}
  @media (max-width:820px){ .touch-guide{font-size:14px;} }

  .tap-bar{display:none; gap:8px; margin-top:10px;}
  .tap-btn{flex:1; padding:14px 10px; border-radius:12px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08); font-weight:800;}
  .tap-btn:active{transform:translateY(1px); filter:brightness(1.05);}
  @media (max-width:820px){ .tap-bar{display:flex;} }

  .results{margin-top:10px; background:rgba(255,255,255,0.03); padding:10px; border-radius:10px;}
  .muted{color:var(--muted); font-size:13px;}
  footer{margin-top:10px; font-size:13px; color:var(--muted);}
</style>
</head>
<body>
<div class="app card">
  <header>
    <div>
      <h1>Tavşan Sayma — Gelişmiş</h1>
      <p class="small">Beyaz tavşanları say. Yanlış olan elenir. Puan tablosu, ses efektleri ve mobil dokunmatik bar eklendi.</p>
    </div>
    <div class="muted">Yerel (aynı klavye / dokunmatik)</div>
  </header>

  <!-- START -->
  <div id="startScreen" class="screen active">
    <div class="row" style="margin-top:10px;">
      <label>Kaç oyuncu?</label>
      <select id="playerCount">
        <option value="2">2</option><option value="3">3</option><option value="4">4</option>
        <option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option>
      </select>
      <button id="defaultsBtn" class="btn">Varsayılan Tuşları Yükle</button>
    </div>

    <div class="players-setup" id="playersSetup"></div>

    <div style="display:flex; gap:8px; align-items:center; margin-top:12px; flex-wrap:wrap;">
      <button id="startBtn" class="start-btn">Başla</button>
      <button id="demoBtn" class="btn">Hemen Demo</button>
      <button id="fsBtn" class="btn">Tam Ekran</button>
      <div class="muted" style="margin-left:12px;">Her oyuncunun tuş kutusuna tıklayıp bir tuşa basın. Mobilde alttaki dokunmatik tuşları kullanabilirsiniz.</div>
    </div>
  </div>

  <!-- GAME -->
  <div id="gameScreen" class="screen">
    <div class="main-row">
      <div class="left-col">
        <div class="hud" id="hud"></div>

        <div id="gameArea" class="game-area" tabindex="0"></div>

        <!-- Mobil dokunmatik tuş çubuğu -->
        <div id="tapBar" class="tap-bar" aria-label="Dokunmatik Oyuncu Tuşları"></div>

        <div class="results" id="resultsPanel">
          <div id="roundMsg" class="muted">Tur bekleniyor...</div>
          <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <button id="nextRoundBtn" class="btn" style="display:none;">Sonraki Tur</button>
            <button id="restartBtn" class="btn" style="display:none;">Yeniden Başlat</button>
          </div>
          <div id="postRoundInfo" style="margin-top:8px;"></div>
        </div>
      </div>

      <div class="right-col">
        <div class="scoreboard" id="scoreboard">
          <div class="score-title">Puan Tablosu</div>
          <div id="scoreList"></div>
        </div>
        <div style="height:12px"></div>
        <div class="muted">Not: Canlı tuş basımı ekranı görünmez — kopya önlemek için.</div>
      </div>
    </div>
  </div>

  <!-- END -->
  <div id="endScreen" class="screen">
    <h2 id="winnerText">Kazanan: —</h2>
    <div id="finalTable"></div>
    <div style="margin-top:10px;">
      <button id="playAgainBtn" class="btn">Tekrar Oyna</button>
    </div>
  </div>

  <footer>İpucu: Mobilde, alttaki dokunmatik tuşları veya ekrandaki şeritleri kullanın. İlk turda bölge çizgileri görünür.</footer>
</div>

<script>
/* Kısa not:
   - 1..14: yatay/sine/zigzag
   - 15..29: yatay + dikey/diag + zigzag/sine
   - 30+: circle türü devrede (ekranda aniden beliren yuvarlak dönen tavşanlar)
*/

/////////////////////
// Yardımcı fn'ler //
/////////////////////
const clamp = (a,b,v) => Math.max(a, Math.min(b, v));
function easeInOutQuad(x){ return x < 0.5 ? 2*x*x : 1 - Math.pow(-2*x+2,2)/2; }
function setPos(objOrEl, x, y){
  // objOrEl: ya rObj ya da DOM el'i olabilir
  if(typeof objOrEl === 'object' && objOrEl.el){
    objOrEl.x = x; objOrEl.y = y;
    const scale = objOrEl.meta && objOrEl.meta.isSlow ? 0.98 : 1;
    objOrEl.el.style.transform = `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0) scale(${scale})`;
  } else {
    const el = objOrEl;
    el.style.transform = `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
  }
}

/////////////////////
/// State & DOM ////
/////////////////////
const defaultKeys = ['A','ArrowUp',' ','P'];
let players = [];
let survivors = [];
let currentRoundSpawned = [];
let visibleRabbits = [];
let roundNum = 0;
let baseRabbits = 5;
let roundActive = false;
let spawnTimers = [];
let rabbitCounter = 0;
let firstTouchGuidesShown = false;
let audioCtx = null;
let audioAllowed = false;
let maxScaleRound = 15;
let touchRegions = [];
const isSmall = () => window.innerWidth <= 820;

const startScreen = document.getElementById('startScreen');
const gameScreen = document.getElementById('gameScreen');
const endScreen = document.getElementById('endScreen');
const playersSetup = document.getElementById('playersSetup');
const playerCountSel = document.getElementById('playerCount');
const defaultsBtn = document.getElementById('defaultsBtn');
const startBtn = document.getElementById('startBtn');
const demoBtn = document.getElementById('demoBtn');
const fsBtn = document.getElementById('fsBtn');
const hud = document.getElementById('hud');
const gameArea = document.getElementById('gameArea');
const tapBar = document.getElementById('tapBar');
const roundMsg = document.getElementById('roundMsg');
const nextRoundBtn = document.getElementById('nextRoundBtn');
const restartBtn = document.getElementById('restartBtn');
const postRoundInfo = document.getElementById('postRoundInfo');
const scoreboardEl = document.getElementById('scoreList');
const winnerText = document.getElementById('winnerText');
const finalTable = document.getElementById('finalTable');
const playAgainBtn = document.getElementById('playAgainBtn');

//////////////////////
// Ses yardımcıları //
//////////////////////
function ensureAudio(){
  if(audioAllowed) return;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioAllowed = true; }catch(e){ audioAllowed = false; }
}
function playTone(freq=440, dur=0.08, type='sine', gainVal=0.08){
  if(!audioAllowed) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = gainVal;
  o.connect(g); g.connect(audioCtx.destination);
  const now = audioCtx.currentTime; o.start(now);
  g.gain.setValueAtTime(g.gain.value, now); g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  o.stop(now + dur + 0.02);
}
const playClick=()=>playTone(900, .05, 'square', .06);
const playSpawn=()=>playTone(620, .06, 'sine', .05);
const playCount=()=>playTone(980, .04, 'sine', .06);
function playSuccess(){ playTone(880,.18,'sine',.08); playTone(1180,.12,'sine',.06); }
const playFail=()=>playTone(220,.16,'sawtooth',.09);
function playCountdown(num){ if(num==='3') playTone(450,.12,'sine',.08); else if(num==='2') playTone(560,.12,'sine',.08); else if(num==='1') playTone(700,.12,'sine',.08); else playTone(980,.18,'square',.12); }
function playWinnerFanfare(){ if(!audioAllowed) return; [660,820,980,1320].forEach((f,i)=> setTimeout(()=> playTone(f,.12,'sine',.09), i*140)); }

//////////////////////
// UI: oyuncular    //
//////////////////////
function keyLabel(k){ if(!k) return '—'; return k===' ' ? 'Space' : (k.length>1 ? k : k.toUpperCase()); }
function colorForIndex(i){ const cols = ['#ffb86b','#7ee787','#7ad7ff','#ff7ac6','#ffd86b','#7affc2','#a89fff','#ff8fb0']; return cols[i%cols.length]; }

function createPlayerSetup(n){
  playersSetup.innerHTML=''; players = [];
  for(let i=0;i<n;i++){
    const id = i+1;
    const card = document.createElement('div');
    card.className='player-card';
    card.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
        <div><div style="font-weight:800">Oyuncu ${id}</div><div class="muted">Tuş atayın</div></div>
        <div style="text-align:right"><div class="muted">Durum</div><div id="status-${id}">Hazır</div></div>
      </div>
      <div style="margin-top:8px;display:flex;align-items:center;gap:8px;">
        <div class="key-box" id="keybox-${id}">—</div>
        <div class="muted">Tıklayıp tuşa basın</div>
      </div>
      <div style="margin-top:8px;font-size:13px;" class="muted">Mobil: oyun sırasında alttaki büyük düğmeleri kullanın.</div>
    `;
    playersSetup.appendChild(card);
    players.push({id, name:`Oyuncu ${id}`, key:'', active:true, points:0});
    ((pid)=>{
      const kb = document.getElementById(`keybox-${pid}`);
      const st = document.getElementById(`status-${pid}`);
      kb.addEventListener('click', ()=>{
        kb.textContent = 'Bas...'; st.textContent = 'Tuş bekleniyor';
        ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        const handler = (ev)=>{
          ev.preventDefault();
          let k = ev.key; if(k===' '||k==='Spacebar') k=' ';
          players.find(p=>p.id===pid).key = k;
          kb.textContent = keyLabel(k); st.textContent = 'Hazır';
          window.removeEventListener('keydown', handler);
        };
        window.addEventListener('keydown', handler);
      });
    })(id);
  }
}
playerCountSel.addEventListener('change', ()=> createPlayerSetup(parseInt(playerCountSel.value)));
defaultsBtn.addEventListener('click', ()=>{
  createPlayerSetup(parseInt(playerCountSel.value));
  for(let i=0;i<players.length;i++){
    players[i].key = i < defaultKeys.length ? defaultKeys[i] : '';
    const kb = document.getElementById(`keybox-${players[i].id}`);
    if(kb) kb.textContent = players[i].key ? keyLabel(players[i].key) : '—';
  }
});

/////////////////////
// HUD & Tap bar   //
/////////////////////
function updateHUD(showCounts=false){
  hud.innerHTML = '';
  survivors.forEach((p, idx)=>{
    const el = document.createElement('div');
    el.className='player-hud';
    el.innerHTML = `<div style="width:12px;height:12px;border-radius:50%;background:${colorForIndex(idx)}"></div>
      <div style="min-width:92px"><div class="player-name">${p.name}</div><div style="font-size:13px;color:var(--muted)">Tuş: <strong>${keyLabel(p.key)}</strong></div></div>
      <div style="margin-left:auto; font-size:13px; color:var(--muted)">${p.active ? 'Aktif' : 'Elendi'}</div>`;
    if(showCounts){
      const c = document.createElement('div');
      c.style.marginLeft='12px'; c.style.fontWeight='700';
      c.textContent = `${p.roundCount||0} saydı`;
      el.appendChild(c);
    }
    hud.appendChild(el);
  });
  const info = document.createElement('div');
  info.className='round-info';
  info.textContent = `Tur: ${roundNum} — Oyuncu: ${survivors.length}`;
  hud.appendChild(info);
  updateScoreboard();
  renderTapBar();
}
function updateScoreboard(){
  scoreboardEl.innerHTML = '';
  players.forEach(p=>{
    let pts = p.points || 0;
    const s = survivors.find(x=>x.id===p.id);
    if(s) pts = s.points || pts;
    const row = document.createElement('div');
    row.className='score-row';
    row.innerHTML = `<div>${p.name}</div><div>${pts} pts</div>`;
    scoreboardEl.appendChild(row);
  });
}
function renderTapBar(){
  tapBar.innerHTML = '';
  survivors.forEach((p, idx)=>{
    const b = document.createElement('button');
    b.className = 'tap-btn';
    b.style.borderColor = 'rgba(255,255,255,0.14)';
    b.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03))';
    b.style.outline = 'none';
    b.innerHTML = `#${idx+1}<div style="font-size:12px;opacity:.8">${p.name}</div>`;
    b.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if(roundActive) playerCountForPlayer(p.id); });
    b.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(roundActive) playerCountForPlayer(p.id); }, {passive:false});
    tapBar.appendChild(b);
  });
}

///////////////////////////
// Touch guide (ilk tur) //
///////////////////////////
function showTouchGuidesOnce(){
  if(firstTouchGuidesShown) return;
  firstTouchGuidesShown = true;
  const guides = document.createElement('div');
  guides.className = 'touch-guides';
  const N = survivors.length || players.length || 4;
  for(let i=0;i<N;i++){
    const g = document.createElement('div');
    g.className = 'touch-guide';
    g.textContent = `Bölge ${i+1}`;
    guides.appendChild(g);
  }
  gameArea.appendChild(guides);
  setTimeout(()=> { if(guides.parentNode) guides.parentNode.removeChild(guides); }, isSmall()? 4200 : 3200);
}

//////////////////////
// Oyun akışı       //
//////////////////////
startBtn.addEventListener('click', ()=>{
  ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  const n = players.length;
  if(n < 2) { alert('En az 2 oyuncu seçin.'); return; }
  const assigned = players.map(p=>p.key);
  if(assigned.filter(k=>k).length < players.length){
    if(!confirm('Bazı oyuncuların tuşu atanmadı. Mobilde alttaki dokunmatik düğmeleri kullanabilirsiniz. Devam edilsin mi?')) return;
  }
  survivors = players.map(p => ({...p, roundCount:0, points:p.points||0, active:true}));
  startGame();
});
demoBtn.addEventListener('click', ()=>{
  playerCountSel.value = '4';
  createPlayerSetup(4);
  defaultsBtn.click();
  startBtn.click();
});
fsBtn.addEventListener('click', ()=>{
  const el = document.documentElement;
  if(!document.fullscreenElement){ if(el.requestFullscreen) el.requestFullscreen(); }
  else{ if(document.exitFullscreen) document.exitFullscreen(); }
});

function startGame(){
  startScreen.classList.remove('active');
  endScreen.classList.remove('active');
  gameScreen.classList.add('active');
  roundNum = 0;
  showTouchGuidesOnce();
  showMessage('Hazır! Başlamak için Sonraki Tur\'a basın.');
  nextRoundBtn.style.display='inline-block';
  restartBtn.style.display='inline-block';
  nextRoundBtn.onclick = ()=> beginCountdownAndStart();
  restartBtn.onclick = ()=> location.reload();
  updateHUD(false);
}

function beginCountdownAndStart(){
  nextRoundBtn.style.display = 'none';
  ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  showOverlayCountdown(['3','2','1','GO'], 700, ()=> startRound());
}
function showOverlayCountdown(seq, msPer, callback){
  const ov = document.createElement('div');
  ov.className = 'overlay'; ov.style.zIndex = 120;
  document.body.appendChild(ov);
  let i=0;
  (function step(){
    if(i>=seq.length){ document.body.removeChild(ov); callback && callback(); return; }
    ov.textContent = seq[i]; playCountdown(seq[i]); ov.style.opacity='1'; ov.style.transform='scale(1.02)';
    setTimeout(()=>{ ov.style.transform='scale(1)'; }, 80);
    i++; setTimeout(step, msPer);
  })();
}

function startRound(){
  if(survivors.length <= 1){ endGame(); return; }
  clearRound();
  roundNum++;
  survivors.forEach(p=> p.roundCount = 0);
  updateHUD(false);
  showMessage(`Tur ${roundNum} başlıyor — dikkat!`, true);

  const scale = Math.min(roundNum, maxScaleRound);
  const minDuration = Math.max(1200 - (scale-1)*60, 300);
  const maxDuration = Math.max(2600 - (scale-1)*90, 700);
  const interval = Math.max(520 - (scale-1)*22, 120);

  roundActive = true;
  computeTouchRegions();

  let spawned = 0;
  const rabbitsCount = baseRabbits + (roundNum-1)*2 + Math.floor(Math.random()*2);
  function spawnLoop(){
    if(spawned >= rabbitsCount){
      const t = setTimeout(()=> finalizeRound(), 900 + Math.random()*300);
      spawnTimers.push(t); return;
    }
    spawned++;
    const color = (Math.random() < 0.7) ? 'white' : 'red';
    const isSlow = Math.random() < 0.14;
    const canReverse = Math.random() < 0.28;
    const meta = {isSlow, canReverse};
    const motionType = pickMotionTypeForRound(roundNum);
    spawnRabbit(color, minDuration, maxDuration, meta, motionType);
    const t = setTimeout(spawnLoop, interval + Math.random()*260 - 120);
    spawnTimers.push(t);
  }
  spawnLoop();
}

//////////////////////////////
// Hareket tipi karar fonks.//
//////////////////////////////
function pickMotionTypeForRound(r){
  // Kullanıcının istediği zorluk dengesi:
  // 1..14 => sadece yatay/sine/zigzag
  // 15..29 => dikey (v) ve diag eklenir (circle yok)
  // 30+ => circle sisteme girer
  if (r < 15) {                      // 1–14
    const rnd = Math.random();
    if (rnd < 0.78) return 'h';
    if (rnd < 0.90) return 'sine';
    return 'zigzag';
  } else if (r < 30) {               // 15–29
    const options = ['h','v','diag','zigzag','sine'];
    const weights = [0.25,0.20,0.20,0.20,0.15];
    let rnum = Math.random() * weights.reduce((a,b)=>a+b,0);
    for (let i=0;i<options.length;i++){ rnum -= weights[i]; if (rnum <= 0) return options[i]; }
    return 'h';
  } else {                           // 30+
    const options = ['h','v','diag','circle','zigzag','sine'];
    const weights = [0.18,0.18,0.16,0.22,0.16,0.10];
    let rnum = Math.random() * weights.reduce((a,b)=>a+b,0);
    for (let i=0;i<options.length;i++){ rnum -= weights[i]; if (rnum <= 0) return options[i]; }
    return 'circle';
  }
}

function clearRound(){
  spawnTimers.forEach(t=> clearTimeout(t)); spawnTimers = [];
  visibleRabbits.forEach(r=> { if(r.el && r.el.parentNode) r.el.remove(); if(r.removeCb) r.removeCb(); });
  visibleRabbits = []; currentRoundSpawned = []; roundActive = false;
}

//////////////////////
// Spawn & animate  //
//////////////////////
function spawnRabbit(color, minD, maxD, meta, motionType){
  rabbitCounter++; const id = rabbitCounter;
  const el = document.createElement('div');
  el.className = `rabbit ${color}` + (meta.isSlow ? ' slow' : '');
  el.setAttribute('data-id', id);
  el.innerHTML = `<div class="body"><div class="ear"></div><div class="ear r"></div><div class="eye"></div><div class="eye" style="left:21px"></div></div>`;
  gameArea.appendChild(el);

  // push currentRoundSpawned (finalde saymak için)
  currentRoundSpawned.push({id, color, meta, motionType});

  // rObj oluştur & görünür listeye ekle
  const rObj = { id, color, el, countedBy: new Set(), meta: {...meta}, motionType, removeCb: null, x:0, y:0 };
  visibleRabbits.push(rObj);

  // hareket parametrelerini spawn anında hesapla (jitter önlemi)
  const areaH = gameArea.clientHeight;
  const areaW = gameArea.clientWidth;
  rObj.meta.params = {
    baseY: 34 + Math.random()*(areaH-68),
    durationScale: 1 + (Math.random()*0.12 - 0.06),
    amp: 20 + Math.random()*26,
    freq: 2 + Math.random()*3,
    zigCount: 2 + Math.floor(Math.random()*3),
    zigAmp: 16 + Math.random()*24,
    circle: {
      cx: 60 + Math.random() * Math.max(1,(areaW - 120)),
      cy: 80 + Math.random() * Math.max(1,(areaH - 160)),
      r: 44 + Math.random() * 84,
      startAngle: Math.random() * Math.PI * 2,
      clockwise: Math.random() > 0.5 ? 1 : -1,
      totalRotScale: 1 + Math.random()*1.6
    }
  };

  playSpawn();

  // süre
  let duration = minD + Math.random()*(maxD - minD);
  if(rObj.meta.isSlow) duration *= 1.6;
  duration *= rObj.meta.params.durationScale;

  // animasyon başlangıcı
  const startTime = performance.now();

  // Yatay / sine / zigzag
  if(motionType === 'h' || motionType === 'sine' || motionType === 'zigzag'){
    const fromLeft = Math.random() > 0.5;
    const startX = fromLeft ? -110 : (areaW + 110);
    const endX = fromLeft ? (areaW + 110) : -110;
    setPos(rObj, startX, rObj.meta.params.baseY);

    const willReverse = rObj.meta.isSlow ? false : (rObj.meta.canReverse && Math.random() < 0.85);

    function animate(now){
      const t = Math.min(1, (now - startTime) / duration);
      const curX = startX + (endX - startX) * easeInOutQuad(t);
      let curY = rObj.meta.params.baseY;

      if(motionType === 'sine'){
        curY = clamp(30, areaH-30, rObj.meta.params.baseY + Math.sin(t * Math.PI * rObj.meta.params.freq) * rObj.meta.params.amp);
      } else if(motionType === 'zigzag'){
        curY = clamp(30, areaH-30, rObj.meta.params.baseY + Math.sin(t * Math.PI * rObj.meta.params.zigCount) * rObj.meta.params.zigAmp);
      }

      setPos(rObj, curX, curY);

      if(willReverse && !rObj.meta._reversed && t > 0.35 + Math.random()*0.45){
        rObj.meta._reversed = true; rObj.el.classList.add('reverse');
        const curLeft = rObj.x;
        const targetX = startX;
        const remainingDist = Math.abs(targetX - curLeft);
        const remainingDuration = Math.max(240, (remainingDist / Math.abs(endX - startX)) * duration * 0.9);
        const revStart = performance.now();
        function rev(now2){
          const tt = Math.min(1, (now2 - revStart) / remainingDuration);
          const cur = curLeft + (targetX - curLeft) * easeInOutQuad(tt);
          setPos(rObj, cur, rObj.y);
          if(tt < 1) requestAnimationFrame(rev);
          else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 140); }
        }
        requestAnimationFrame(rev);
        return;
      }

      if(t < 1) requestAnimationFrame(animate);
      else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 140); }
    }
    requestAnimationFrame(animate);

  } else if(motionType === 'v' || motionType === 'diag'){
    // dikey / diagonal (15. tur ve sonrası)
    const fromTop = Math.random() > 0.5;
    const startY = fromTop ? -86 : (areaH + 86);
    const endY = fromTop ? (areaH + 86) : -86;
    const startX = 44 + Math.random()*(areaW-88);
    const endX = (motionType === 'diag') ? (Math.random()>0.5 ? areaW+86 : -86) : startX;
    setPos(rObj, startX, startY);

    const willReverse = rObj.meta.canReverse && Math.random() < 0.75;

    function animate(now){
      const t = Math.min(1, (now - startTime) / duration);
      const curY = startY + (endY - startY) * easeInOutQuad(t);
      const curX = startX + (endX - startX) * easeInOutQuad(t);
      setPos(rObj, curX, curY);

      if(willReverse && !rObj.meta._reversed && t > 0.25 + Math.random()*0.5){
        rObj.meta._reversed = true; rObj.el.classList.add('reverse');
        const curTop = rObj.y;
        const targetY = startY;
        const remainingDist = Math.abs(targetY - curTop);
        const remainingDuration = Math.max(260, (remainingDist / Math.abs(endY - startY)) * duration * 0.9);
        const revStart = performance.now();
        function rev(now2){
          const tt = Math.min(1, (now2 - revStart) / remainingDuration);
          const cy = curTop + (targetY - curTop) * easeInOutQuad(tt);
          setPos(rObj, rObj.x, cy);
          if(tt < 1) requestAnimationFrame(rev);
          else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 160); }
        }
        requestAnimationFrame(rev);
        return;
      }

      if(t < 1) requestAnimationFrame(animate);
      else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 140); }
    }
    requestAnimationFrame(animate);

  } else if(motionType === 'circle'){
    // 30+ tur için: ortada belirip dönen tavşanlar (circle)
    const {cx, cy, r, startAngle, clockwise, totalRotScale} = rObj.meta.params.circle;
    const totalRot = (Math.PI * 2) * totalRotScale * clockwise;
    function animate(now){
      const t = Math.min(1, (now - startTime) / duration);
      const angle = startAngle + totalRot * easeInOutQuad(t);
      const x = cx + Math.cos(angle) * r;
      const y2 = cy + Math.sin(angle) * r;
      setPos(rObj, x - 32, y2 - 32);

      const willReverse = rObj.meta.canReverse && !rObj.meta._reversed;
      if(willReverse && t > 0.35 + Math.random()*0.4){
        rObj.meta._reversed = true; rObj.el.classList.add('reverse');
        const curAngle = angle;
        const endAngle = curAngle - totalRot * 0.6;
        const revStart = performance.now();
        const revDur = Math.max(300, duration * 0.45);
        function rev(now2){
          const tt = Math.min(1, (now2 - revStart)/revDur);
          const a = curAngle + (endAngle - curAngle) * easeInOutQuad(tt);
          const rr = r + 12 * tt;
          const xx = cx + Math.cos(a)*rr;
          const yy = cy + Math.sin(a)*rr;
          setPos(rObj, xx - 32, yy - 32);
          if(tt < 1) requestAnimationFrame(rev);
          else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 160); }
        }
        requestAnimationFrame(rev);
        return;
      }

      if(t < 1) requestAnimationFrame(animate);
      else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 140); }
    }
    requestAnimationFrame(animate);

  } else {
    // fallback: basit yatay geçiş
    const endX = areaW + 110;
    setPos(rObj, -110, rObj.meta.params.baseY);
    function animate(now){
      const t = Math.min(1, (now - startTime) / duration);
      const cur = -110 + (endX + 110) * easeInOutQuad(t);
      setPos(rObj, cur, rObj.meta.params.baseY);
      if(t < 1) requestAnimationFrame(animate);
      else { rObj.el.classList.add('fade'); setTimeout(()=> removeRabbitById(id), 140); }
    }
    requestAnimationFrame(animate);
  }

  // remove callback
  rObj.removeCb = ()=> {
    visibleRabbits = visibleRabbits.filter(v=>v.id !== id);
    if(el.parentNode) el.parentNode.removeChild(el);
  };
}

function removeRabbitById(id){
  const idx = visibleRabbits.findIndex(r=>r.id===id);
  if(idx !== -1){
    const r = visibleRabbits[idx];
    if(r.removeCb) r.removeCb();
    visibleRabbits = visibleRabbits.filter(v=>v.id !== id);
  } else {
    const el = gameArea.querySelector(`.rabbit[data-id='${id}']`);
    if(el && el.parentNode) el.parentNode.removeChild(el);
  }
}

//////////////////////
// Girdiler         //
//////////////////////
window.addEventListener('keydown', (ev)=>{
  if(!roundActive) return;
  let key = ev.key; if(key===' '||key==='Spacebar') key=' ';
  ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  const player = survivors.find(p=> p.key && p.key === key && p.active);
  if(!player) return;
  playerCountForPlayer(player.id);
});

gameArea.addEventListener('pointerdown', (ev)=>{
  if(!roundActive) return;
  const rect = gameArea.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const playerId = getPlayerIdFromX(x);
  if(!playerId) return;
  const player = survivors.find(p=>p.id === playerId && p.active);
  if(!player) return;
  ev.preventDefault();
  playerCountForPlayer(player.id);
});
gameArea.addEventListener('touchstart', (e)=>{ if(roundActive) e.preventDefault(); }, {passive:false});
gameArea.addEventListener('touchmove', (e)=>{ if(roundActive) e.preventDefault(); }, {passive:false});

function computeTouchRegions(){
  touchRegions = [];
  const N = survivors.length;
  if(N === 0) return;
  const W = gameArea.clientWidth;
  for(let i=0;i<N;i++){
    const x1 = Math.floor(i * W / N);
    const x2 = Math.floor((i+1) * W / N);
    touchRegions.push({x1, x2, playerId: survivors[i].id});
  }
}
function getPlayerIdFromX(x){
  for(const r of touchRegions) if(x >= r.x1 && x < r.x2) return r.playerId;
  return touchRegions.length ? touchRegions[touchRegions.length-1].playerId : null;
}

function playerCountForPlayer(pid){
  if(!roundActive) return;
  // oyuncunun her sayımı, beyaz tavşanlardan sayılır (kesişim yok)
  for(const r of visibleRabbits){
    if(r.color === 'white' && !r.countedBy.has(pid)){
      r.countedBy.add(pid);
      const p = survivors.find(s=>s.id === pid);
      if(p) p.roundCount = (p.roundCount||0) + 1;
      playCount(); flashPlayer(pid);
      return;
    }
  }
  // eğer uygun beyaz yoksa hata sesi
  playFail();
}

function flashPlayer(pid){
  const nodes = hud.querySelectorAll('.player-hud');
  nodes.forEach(node=>{
    if(node.textContent.includes(`Oyuncu ${pid}`)){
      node.style.transform='translateY(-6px)';
      setTimeout(()=> node.style.transform = '', 150);
    }
  });
}

//////////////////////
// Tur sonu         //
//////////////////////
function finalizeRound(){
  roundActive = false;
  const actualWhite = currentRoundSpawned.filter(s => s.color === 'white').length;

  survivors.forEach(p => {
    p.points = (p.points || 0) + (p.roundCount || 0);
    const main = players.find(x=>x.id===p.id);
    if(main) main.points = p.points;
  });

  const correct = [], eliminated = [];
  survivors.forEach(p=>{ ((p.roundCount||0) === actualWhite) ? correct.push(p) : eliminated.push(p); });

  let msg = `Gerçek beyaz tavşan sayısı: ${actualWhite}. `;
  if(correct.length === 0){
    msg += 'Kimse tam doğru saymadı. Elenen yok; aynı oyuncularla bir sonraki tur (daha zor).';
    updateHUD(true); playFail();
  } else if(correct.length === 1){
    msg += `${correct[0].name} tam doğru bildi ve KAZANDI!`;
    survivors = correct; updateHUD(true); playWinnerFanfare();
    setTimeout(()=> endGame(), 900); currentRoundSpawned = []; return;
  } else {
    msg += `Doğru yapanlar: ${correct.map(p=>p.name).join(', ')}. Diğerleri elendi.`;
    survivors = correct.map(p => ({...p, active:true}));
    updateHUD(true); playSuccess();
  }

  showMessage(msg, false);

  postRoundInfo.innerHTML = '';
  const sorted = players.slice().sort((a,b)=> (b.points||0) - (a.points||0));
  sorted.forEach(p=>{
    const d = document.createElement('div');
    d.className = 'muted';
    d.textContent = `${p.name} — ${p.points || 0} pts`;
    postRoundInfo.appendChild(d);
  });

  currentRoundSpawned = [];
  nextRoundBtn.style.display='inline-block';
  nextRoundBtn.textContent = 'Sonraki Tur';
  nextRoundBtn.onclick = ()=> beginCountdownAndStart();
  updateHUD(false);
}

//////////////////////
// Oyun bitiş       //
//////////////////////
function endGame(){
  clearRound();
  gameScreen.classList.remove('active');
  endScreen.classList.add('active');
  const winner = survivors[0];
  winnerText.textContent = winner ? `Kazanan: ${winner.name}` : 'Kazanan yok';
  finalTable.innerHTML = '<div class="muted">Sonuçlar (puanlar):</div>';
  const sorted = players.slice().sort((a,b)=> (b.points||0) - (a.points||0));
  sorted.forEach(p=>{
    const d = document.createElement('div');
    d.textContent = `${p.name} — ${p.points || 0} pts`;
    finalTable.appendChild(d);
  });
  playWinnerFanfare();
  playAgainBtn.onclick = ()=> location.reload();
}

//////////////////////
// Init & helpers   //
//////////////////////
playerCountSel.addEventListener('change', ()=> createPlayerSetup(parseInt(playerCountSel.value)));
createPlayerSetup(parseInt(playerCountSel.value));
defaultsBtn.click();

window.addEventListener('resize', ()=> { if(roundActive) computeTouchRegions(); });

function showMessage(txt, hint=false){
  roundMsg.textContent = txt;
  roundMsg.style.color = hint ? '#dff3ff' : 'var(--muted)';
}
</script>
</body>
</html>
